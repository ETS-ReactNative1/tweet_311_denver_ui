{"version":3,"sources":["../../src/logs/RemoteLogging.ts"],"names":[],"mappings":"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","sourcesContent":["import Constants from 'expo-constants';\nimport { EventEmitter, EventSubscription } from 'fbemitter';\nimport invariant from 'invariant';\nimport UUID from 'uuid-js';\n\nimport LogSerialization from './LogSerialization';\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ntype LogEntry = {\n  count: number;\n  level: LogLevel;\n  body: LogData[];\n  includesStack: boolean;\n  groupDepth?: number;\n} & LogEntryFields;\n\nexport type LogEntryFields = {\n  shouldHide?: boolean;\n  groupDepth?: number;\n  groupCollapsed?: boolean;\n};\n\nexport type LogData = string | LogErrorData;\nexport type LogErrorData = { message: string; stack: string };\n\ntype TransportErrorListener = (event: { error: Error; response?: Response }) => void;\n\nconst _sessionId = UUID.create().toString();\nconst _logQueue: LogEntry[] = [];\nconst _transportEventEmitter = new EventEmitter();\n\nlet _logCounter = 0;\nlet _isSendingLogs = false;\nlet _completionPromise: Promise<void> | null = null;\nlet _resolveCompletion: (() => void) | null = null;\n\nasync function enqueueRemoteLogAsync(\n  level: LogLevel,\n  additionalFields: LogEntryFields,\n  data: unknown[]\n): Promise<void> {\n  if (_isReactNativeWarning(data)) {\n    // Remove the stack trace from the warning message since we'll capture our own\n    if (data.length === 0) {\n      throw new Error(`Warnings must include log arguments`);\n    }\n    const warning = data[0];\n    if (typeof warning !== 'string') {\n      throw new TypeError(`The log argument for a warning must be a string`);\n    }\n    const lines = warning.split('\\n');\n    if (lines.length > 1 && /^\\s+in /.test(lines[1])) {\n      data[0] = lines[0];\n    }\n  }\n\n  let { body, includesStack } = await LogSerialization.serializeLogDataAsync(data, level);\n\n  _logQueue.push({\n    count: _logCounter++,\n    level,\n    body,\n    includesStack,\n    ...additionalFields,\n  });\n\n  // Send the logs asynchronously (system errors are emitted with transport error events) and throw an uncaught error\n  _sendRemoteLogsAsync().catch(error => {\n    setImmediate(() => {\n      throw error;\n    });\n  });\n}\n\nasync function _sendRemoteLogsAsync(): Promise<void> {\n  if (_isSendingLogs || !_logQueue.length) {\n    return;\n  }\n\n  // Our current transport policy is to send all of the pending log messages in one batch. If we opt\n  // for another policy (ex: throttling) this is where to to implement it.\n  let batch = _logQueue.splice(0);\n\n  let { logUrl } = Constants.manifest;\n  if (typeof logUrl !== 'string') {\n    throw new Error('The Expo project manifest must specify `logUrl`');\n  }\n\n  _isSendingLogs = true;\n  try {\n    await _sendNextLogBatchAsync(batch, logUrl);\n  } finally {\n    _isSendingLogs = false;\n  }\n\n  if (_logQueue.length) {\n    return _sendRemoteLogsAsync();\n  } else if (_resolveCompletion) {\n    _resolveCompletion();\n  }\n}\n\nasync function _sendNextLogBatchAsync(batch: LogEntry[], logUrl: string): Promise<void> {\n  let response;\n\n  let headers = {\n    'Content-Type': 'application/json',\n    Connection: 'keep-alive',\n    'Proxy-Connection': 'keep-alive',\n    Accept: 'application/json',\n    'Device-Id': Constants.installationId,\n    'Session-Id': _sessionId,\n  };\n  if (Constants.deviceName) {\n    headers['Device-Name'] = Constants.deviceName;\n  }\n  try {\n    response = await fetch(logUrl, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(batch),\n    });\n  } catch (error) {\n    _transportEventEmitter.emit('error', { error });\n    return;\n  }\n\n  let success = response.status >= 200 && response.status < 300;\n  if (!success) {\n    _transportEventEmitter.emit('error', {\n      error: new Error(`An HTTP error occurred when sending remote logs`),\n      response,\n    });\n  }\n}\n\nfunction addTransportErrorListener(listener: TransportErrorListener): EventSubscription {\n  return _transportEventEmitter.addListener('error', listener);\n}\n\nfunction _isReactNativeWarning(data: unknown[]): boolean {\n  // NOTE: RN does the same thing internally for YellowBox\n  let message = data[0];\n  return data.length === 1 && typeof message === 'string' && message.startsWith('Warning: ');\n}\n\nexport default {\n  enqueueRemoteLogAsync,\n  addTransportErrorListener,\n};\n\n/**\n * Returns a promise that resolves when all entries in the log queue have been sent. This method is\n * intended for testing only.\n */\nexport function __waitForEmptyLogQueueAsync(): Promise<void> {\n  if (_completionPromise) {\n    return _completionPromise;\n  }\n\n  if (!_isSendingLogs && !_logQueue.length) {\n    return Promise.resolve();\n  }\n\n  _completionPromise = new Promise(resolve => {\n    _resolveCompletion = () => {\n      invariant(!_isSendingLogs, `Must not be sending logs at completion`);\n      invariant(!_logQueue.length, `Log queue must be empty at completion`);\n\n      _completionPromise = null;\n      _resolveCompletion = null;\n\n      resolve();\n    };\n  });\n  return _completionPromise;\n}\n"],"sourceRoot":""}