{"version":3,"sources":["../src/NativeModulesProxy.ts"],"names":[],"mappings":";;;;;;;;;AAAA;;AAEA,IAAM,WAAW,GAAG,2BAAc,oBAAlC;AACA,IAAM,mBAAmB,GAAG,kBAA5B;AACA,IAAM,kBAAkB,GAAG,iBAA3B;AAQA,IAAM,kBAAkB,GAAgD,EAAxE;;AAEA,IAAI,WAAJ,EAAiB;AACf,EAAA,MAAM,CAAC,IAAP,CAAY,WAAW,CAAC,kBAAD,CAAvB,EAA6C,OAA7C,CAAqD,UAAA,UAAU,EAAG;AAChE,IAAA,kBAAkB,CAAC,UAAD,CAAlB,GAAiC,WAAW,CAAC,mBAAD,CAAX,CAAiC,UAAjC,KAAgD,EAAjF;AACA,IAAA,WAAW,CAAC,kBAAD,CAAX,CAAgC,UAAhC,EAA4C,OAA5C,CAAoD,UAAA,UAAU,EAAG;AAC/D,MAAA,kBAAkB,CAAC,UAAD,CAAlB,CAA+B,UAAU,CAAC,IAA1C,IAAkD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAGxC,gBAAA,GAHwC,GAGhB,UAHgB,CAGxC,GAHwC,EAGnC,cAHmC,GAGhB,UAHgB,CAGnC,cAHmC;;AAAA,0CAC7C,IAD6C;AAC7C,kBAAA,IAD6C;AAAA;;AAAA,sBAI5C,cAAc,KAAK,IAAI,CAAC,MAJoB;AAAA;AAAA;AAAA;;AAAA,sBAKxC,IAAI,KAAJ,oBACa,UADb,SAC2B,UAAU,CAAC,IADtC,iBACsD,cADtD,UAEF,cAAc,KAAK,CAAnB,GAAuB,UAAvB,GAAoC,WAFlC,uBAGa,IAAI,CAAC,MAHlB,CALwC;;AAAA;AAAA;AAAA,kDAWnC,WAAW,CAAC,UAAZ,CAAuB,UAAvB,EAAmC,GAAnC,EAAwC,IAAxC,CAXmC;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAlD;AAaD,KAdD;;AAqBA,IAAA,kBAAkB,CAAC,UAAD,CAAlB,CAA+B,WAA/B,GAA6C;AAAA;;AAAA,yCAAI,IAAJ;AAAI,QAAA,IAAJ;AAAA;;AAAA,aAC3C,oDAAc,yBAAd,EAAwC,kBAAxC,+BAA2D,UAA3D,SAA0E,IAA1E,EAD2C;AAAA,KAA7C;;AAEA,IAAA,kBAAkB,CAAC,UAAD,CAAlB,CAA+B,eAA/B,GAAiD;AAAA;;AAAA,yCAAI,IAAJ;AAAI,QAAA,IAAJ;AAAA;;AAAA,aAC/C,qDAAc,yBAAd,EAAwC,sBAAxC,gCAA+D,UAA/D,SAA8E,IAA9E,EAD+C;AAAA,KAAjD;AAED,GA3BD;AA4BD,CA7BD,MA6BO;AACL,EAAA,OAAO,CAAC,IAAR;AAGD;;eAEc,kB","sourcesContent":["import { NativeModules } from 'react-native';\n\nconst NativeProxy = NativeModules.NativeUnimoduleProxy;\nconst modulesConstantsKey = 'modulesConstants';\nconst exportedMethodsKey = 'exportedMethods';\n\ntype ProxyNativeModule = {\n  [propertyName: string]: any;\n  addListener: (eventName: string) => void;\n  removeListeners: (count: number) => void;\n};\n\nconst NativeModulesProxy: { [moduleName: string]: ProxyNativeModule } = {};\n\nif (NativeProxy) {\n  Object.keys(NativeProxy[exportedMethodsKey]).forEach(moduleName => {\n    NativeModulesProxy[moduleName] = NativeProxy[modulesConstantsKey][moduleName] || {};\n    NativeProxy[exportedMethodsKey][moduleName].forEach(methodInfo => {\n      NativeModulesProxy[moduleName][methodInfo.name] = async (\n        ...args: unknown[]\n      ): Promise<any> => {\n        const { key, argumentsCount } = methodInfo;\n        if (argumentsCount !== args.length) {\n          throw new Error(\n            `Native method ${moduleName}.${methodInfo.name} expects ${argumentsCount} ${\n              argumentsCount === 1 ? 'argument' : 'arguments'\n            } but received ${args.length}`\n          );\n        }\n        return await NativeProxy.callMethod(moduleName, key, args);\n      };\n    });\n\n    // These are called by EventEmitter (which is a wrapper for NativeEventEmitter)\n    // only on iOS and they use iOS-specific native module, EXReactNativeEventEmitter.\n    //\n    // On Android only {start,stop}Observing are called on the native module\n    // and these should be exported as Expo methods.\n    NativeModulesProxy[moduleName].addListener = (...args) =>\n      NativeModules.UMReactNativeEventEmitter.addProxiedListener(moduleName, ...args);\n    NativeModulesProxy[moduleName].removeListeners = (...args) =>\n      NativeModules.UMReactNativeEventEmitter.removeProxiedListeners(moduleName, ...args);\n  });\n} else {\n  console.warn(\n    `The \"UMNativeModulesProxy\" native module is not exported through NativeModules; verify that @unimodules/react-native-adapter's native code is linked properly`\n  );\n}\n\nexport default NativeModulesProxy;\n"],"sourceRoot":""}