9cff9e90b63f5edcc30ed4edac67299f
'use strict';

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _SwitchNativeComponent = _interopRequireDefault(require("./SwitchNativeComponent"));

var AndroidSwitchNativeComponent = require("./AndroidSwitchNativeComponent");

var Platform = require("../../Utilities/Platform");

var React = require('react');

var StyleSheet = require("../../StyleSheet/StyleSheet");

var Switch = function (_React$Component) {
  (0, _inherits2.default)(Switch, _React$Component);

  function Switch() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, Switch);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Switch)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _this._handleChange = function (event) {
      if (_this._nativeSwitchRef == null) {
        return;
      }

      var value = _this.props.value === true;

      if (Platform.OS === 'android') {
        _this._nativeSwitchRef.setNativeProps({
          on: value
        });
      } else {
        _this._nativeSwitchRef.setNativeProps({
          value: value
        });
      }

      if (_this.props.onChange != null) {
        _this.props.onChange(event);
      }

      if (_this.props.onValueChange != null) {
        _this.props.onValueChange(event.nativeEvent.value);
      }
    };

    _this._handleSwitchNativeComponentRef = function (ref) {
      _this._nativeSwitchRef = ref;
    };

    return _this;
  }

  (0, _createClass2.default)(Switch, [{
    key: "render",
    value: function render() {
      var _props$accessibilityR2;

      var _this$props = this.props,
          disabled = _this$props.disabled,
          ios_backgroundColor = _this$props.ios_backgroundColor,
          onChange = _this$props.onChange,
          onValueChange = _this$props.onValueChange,
          style = _this$props.style,
          thumbColor = _this$props.thumbColor,
          trackColor = _this$props.trackColor,
          value = _this$props.value,
          props = (0, _objectWithoutProperties2.default)(_this$props, ["disabled", "ios_backgroundColor", "onChange", "onValueChange", "style", "thumbColor", "trackColor", "value"]);
      var _thumbColor = thumbColor;

      var _trackColorForFalse = trackColor == null ? void 0 : trackColor.false;

      var _trackColorForTrue = trackColor == null ? void 0 : trackColor.true;

      var _ref = props,
          thumbTintColor = _ref.thumbTintColor,
          tintColor = _ref.tintColor,
          onTintColor = _ref.onTintColor;

      if (thumbTintColor != null) {
        _thumbColor = thumbTintColor;

        if (__DEV__) {
          console.warn('Switch: `thumbTintColor` is deprecated, use `thumbColor` instead.');
        }
      }

      if (tintColor != null) {
        _trackColorForFalse = tintColor;

        if (__DEV__) {
          console.warn('Switch: `tintColor` is deprecated, use `trackColor` instead.');
        }
      }

      if (onTintColor != null) {
        _trackColorForTrue = onTintColor;

        if (__DEV__) {
          console.warn('Switch: `onTintColor` is deprecated, use `trackColor` instead.');
        }
      }

      if (Platform.OS === 'android') {
        var _props$accessibilityR;

        var _platformProps = {
          enabled: disabled !== true,
          on: value === true,
          style: style,
          thumbTintColor: _thumbColor,
          trackColorForFalse: _trackColorForFalse,
          trackColorForTrue: _trackColorForTrue,
          trackTintColor: value === true ? _trackColorForTrue : _trackColorForFalse
        };
        return React.createElement(AndroidSwitchNativeComponent, (0, _extends2.default)({}, props, _platformProps, {
          accessibilityRole: (_props$accessibilityR = props.accessibilityRole) != null ? _props$accessibilityR : 'button',
          onChange: this._handleChange,
          onResponderTerminationRequest: returnsFalse,
          onStartShouldSetResponder: returnsTrue,
          ref: this._handleSwitchNativeComponentRef
        }));
      }

      var platformProps = {
        disabled: disabled,
        onTintColor: _trackColorForTrue,
        style: StyleSheet.compose({
          height: 31,
          width: 51
        }, StyleSheet.compose(style, ios_backgroundColor == null ? null : {
          backgroundColor: ios_backgroundColor,
          borderRadius: 16
        })),
        thumbTintColor: _thumbColor,
        tintColor: _trackColorForFalse,
        value: value === true
      };
      return React.createElement(_SwitchNativeComponent.default, (0, _extends2.default)({}, props, platformProps, {
        accessibilityRole: (_props$accessibilityR2 = props.accessibilityRole) != null ? _props$accessibilityR2 : 'button',
        onChange: this._handleChange,
        onResponderTerminationRequest: returnsFalse,
        onStartShouldSetResponder: returnsTrue,
        ref: this._handleSwitchNativeComponentRef
      }));
    }
  }]);
  return Switch;
}(React.Component);

var returnsFalse = function returnsFalse() {
  return false;
};

var returnsTrue = function returnsTrue() {
  return true;
};

module.exports = Switch;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlN3aXRjaC5qcyJdLCJuYW1lcyI6WyJBbmRyb2lkU3dpdGNoTmF0aXZlQ29tcG9uZW50IiwicmVxdWlyZSIsIlBsYXRmb3JtIiwiUmVhY3QiLCJTdHlsZVNoZWV0IiwiU3dpdGNoIiwiX2hhbmRsZUNoYW5nZSIsImV2ZW50IiwiX25hdGl2ZVN3aXRjaFJlZiIsInZhbHVlIiwicHJvcHMiLCJPUyIsInNldE5hdGl2ZVByb3BzIiwib24iLCJvbkNoYW5nZSIsIm9uVmFsdWVDaGFuZ2UiLCJuYXRpdmVFdmVudCIsIl9oYW5kbGVTd2l0Y2hOYXRpdmVDb21wb25lbnRSZWYiLCJyZWYiLCJkaXNhYmxlZCIsImlvc19iYWNrZ3JvdW5kQ29sb3IiLCJzdHlsZSIsInRodW1iQ29sb3IiLCJ0cmFja0NvbG9yIiwiX3RodW1iQ29sb3IiLCJfdHJhY2tDb2xvckZvckZhbHNlIiwiZmFsc2UiLCJfdHJhY2tDb2xvckZvclRydWUiLCJ0cnVlIiwidGh1bWJUaW50Q29sb3IiLCJ0aW50Q29sb3IiLCJvblRpbnRDb2xvciIsIl9fREVWX18iLCJjb25zb2xlIiwid2FybiIsInBsYXRmb3JtUHJvcHMiLCJlbmFibGVkIiwidHJhY2tDb2xvckZvckZhbHNlIiwidHJhY2tDb2xvckZvclRydWUiLCJ0cmFja1RpbnRDb2xvciIsImFjY2Vzc2liaWxpdHlSb2xlIiwicmV0dXJuc0ZhbHNlIiwicmV0dXJuc1RydWUiLCJjb21wb3NlIiwiaGVpZ2h0Iiwid2lkdGgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJSYWRpdXMiLCJDb21wb25lbnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFVQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBVUE7O0FBUkEsSUFBTUEsNEJBQTRCLEdBQUdDLE9BQU8sa0NBQTVDOztBQUNBLElBQU1DLFFBQVEsR0FBR0QsT0FBTyw0QkFBeEI7O0FBQ0EsSUFBTUUsS0FBSyxHQUFHRixPQUFPLENBQUMsT0FBRCxDQUFyQjs7QUFDQSxJQUFNRyxVQUFV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O0FBb0JBLGFBQ0Usb0JBQUMsOEJBQUQsNkJBQ01DLEtBRE4sRUFFTXlCLGFBRk47QUFHRSxRQUFBLGlCQUFpQiw0QkFBRXpCLEtBQUssQ0FBQzhCLGlCQUFSLHFDQUE2QixRQUhoRDtBQUlFLFFBQUEsUUFBUSxFQUFFLEtBQUtsQyxhQUpqQjtBQUtFLFFBQUEsNkJBQTZCLEVBQUVtQyxZQUxqQztBQU1FLFFBQUEseUJBQXlCLEVBQUVDLFdBTjdCO0FBT0UsUUFBQSxHQUFHLEVBQUUsS0FBS3pCO0FBUFosU0FERjtBQVdEOzs7RUExR2tCZCxLQUFLLENBQUM2QyxTOztBQTJJM0IsSUFBTVAsWUFBWSxHQUFHLFNBQWZBLFlBQWU7QUFBQSxTQUFNLEtBQU47QUFBQSxDQUFyQjs7QUFDQSxJQUFNQyxXQUFXLEdBQUcsU0FBZEEsV0FBYztBQUFBLFNBQU0sSUFBTjtBQUFBLENBQXBCOztBQUVBTyxNQUFNLENBQUNDLE9BQVAsR0FBaUI3QyxNQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGZsb3dcbiAqIEBmb3JtYXRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEFuZHJvaWRTd2l0Y2hOYXRpdmVDb21wb25lbnQgPSByZXF1aXJlKCcuL0FuZHJvaWRTd2l0Y2hOYXRpdmVDb21wb25lbnQnKTtcbmNvbnN0IFBsYXRmb3JtID0gcmVxdWlyZSgnLi4vLi4vVXRpbGl0aWVzL1BsYXRmb3JtJyk7XG5jb25zdCBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5jb25zdCBTdHlsZVNoZWV0ID0gcmVxdWlyZSgnLi4vLi4vU3R5bGVTaGVldC9TdHlsZVNoZWV0Jyk7XG5cbmltcG9ydCB0eXBlIHtDb2xvclZhbHVlfSBmcm9tICcuLi8uLi9TdHlsZVNoZWV0L1N0eWxlU2hlZXRUeXBlcyc7XG5pbXBvcnQgdHlwZSB7U3ludGhldGljRXZlbnR9IGZyb20gJy4uLy4uL1R5cGVzL0NvcmVFdmVudFR5cGVzJztcbmltcG9ydCB0eXBlIHtWaWV3UHJvcHN9IGZyb20gJy4uL1ZpZXcvVmlld1Byb3BUeXBlcyc7XG5pbXBvcnQgU3dpdGNoTmF0aXZlQ29tcG9uZW50IGZyb20gJy4vU3dpdGNoTmF0aXZlQ29tcG9uZW50JztcblxudHlwZSBTd2l0Y2hDaGFuZ2VFdmVudCA9IFN5bnRoZXRpY0V2ZW50PFxuICAkUmVhZE9ubHk8e3xcbiAgICB2YWx1ZTogYm9vbGVhbixcbiAgfH0+LFxuPjtcblxuZXhwb3J0IHR5cGUgUHJvcHMgPSAkUmVhZE9ubHk8e3xcbiAgLi4uVmlld1Byb3BzLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzd2l0Y2ggaXMgZGlzYWJsZWQuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKi9cbiAgZGlzYWJsZWQ/OiA/Ym9vbGVhbixcblxuICAvKipcbiAgICogQm9vbGVhbiB2YWx1ZSBvZiB0aGUgc3dpdGNoLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICovXG4gIHZhbHVlPzogP2Jvb2xlYW4sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSBjb2xvciBmb3IgdGhlIHN3aXRjaCB0aHVtYi5cbiAgICovXG4gIHRodW1iQ29sb3I/OiA/Q29sb3JWYWx1ZSxcblxuICAvKipcbiAgICogQ3VzdG9tIGNvbG9ycyBmb3IgdGhlIHN3aXRjaCB0cmFjay5cbiAgICpcbiAgICogTk9URTogT24gaU9TIHdoZW4gdGhlIHN3aXRjaCB2YWx1ZSBpcyBmYWxzZSwgdGhlIHRyYWNrIHNocmlua3MgaW50byB0aGVcbiAgICogYm9yZGVyLiBJZiB5b3Ugd2FudCB0byBjaGFuZ2UgdGhlIGNvbG9yIG9mIHRoZSBiYWNrZ3JvdW5kIGV4cG9zZWQgYnkgdGhlXG4gICAqIHNocnVua2VuIHRyYWNrLCB1c2UgYGlvc19iYWNrZ3JvdW5kQ29sb3JgLlxuICAgKi9cbiAgdHJhY2tDb2xvcj86ID8kUmVhZE9ubHk8e3xcbiAgICBmYWxzZT86ID9Db2xvclZhbHVlLFxuICAgIHRydWU/OiA/Q29sb3JWYWx1ZSxcbiAgfH0+LFxuXG4gIC8qKlxuICAgKiBPbiBpT1MsIGN1c3RvbSBjb2xvciBmb3IgdGhlIGJhY2tncm91bmQuIFRoaXMgYmFja2dyb3VuZCBjb2xvciBjYW4gYmUgc2VlblxuICAgKiBlaXRoZXIgd2hlbiB0aGUgc3dpdGNoIHZhbHVlIGlzIGZhbHNlIG9yIHdoZW4gdGhlIHN3aXRjaCBpcyBkaXNhYmxlZCAoYW5kXG4gICAqIHRoZSBzd2l0Y2ggaXMgdHJhbnNsdWNlbnQpLlxuICAgKi9cbiAgaW9zX2JhY2tncm91bmRDb2xvcj86ID9Db2xvclZhbHVlLFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlciB0cmllcyB0byBjaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBzd2l0Y2guXG4gICAqXG4gICAqIFJlY2VpdmVzIHRoZSBjaGFuZ2UgZXZlbnQgYXMgYW4gYXJndW1lbnQuIElmIHlvdSB3YW50IHRvIG9ubHkgcmVjZWl2ZSB0aGVcbiAgICogbmV3IHZhbHVlLCB1c2UgYG9uVmFsdWVDaGFuZ2VgIGluc3RlYWQuXG4gICAqL1xuICBvbkNoYW5nZT86ID8oZXZlbnQ6IFN3aXRjaENoYW5nZUV2ZW50KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZCxcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgdHJpZXMgdG8gY2hhbmdlIHRoZSB2YWx1ZSBvZiB0aGUgc3dpdGNoLlxuICAgKlxuICAgKiBSZWNlaXZlcyB0aGUgbmV3IHZhbHVlIGFzIGFuIGFyZ3VtZW50LiBJZiB5b3Ugd2FudCB0byBpbnN0ZWFkIHJlY2VpdmUgYW5cbiAgICogZXZlbnQsIHVzZSBgb25DaGFuZ2VgLlxuICAgKi9cbiAgb25WYWx1ZUNoYW5nZT86ID8odmFsdWU6IGJvb2xlYW4pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkLFxufH0+O1xuXG4vKipcbiAqIEEgdmlzdWFsIHRvZ2dsZSBiZXR3ZWVuIHR3byBtdXR1YWxseSBleGNsdXNpdmUgc3RhdGVzLlxuICpcbiAqIFRoaXMgaXMgYSBjb250cm9sbGVkIGNvbXBvbmVudCB0aGF0IHJlcXVpcmVzIGFuIGBvblZhbHVlQ2hhbmdlYCBjYWxsYmFjayB0aGF0XG4gKiB1cGRhdGVzIHRoZSBgdmFsdWVgIHByb3AgaW4gb3JkZXIgZm9yIHRoZSBjb21wb25lbnQgdG8gcmVmbGVjdCB1c2VyIGFjdGlvbnMuXG4gKiBJZiB0aGUgYHZhbHVlYCBwcm9wIGlzIG5vdCB1cGRhdGVkLCB0aGUgY29tcG9uZW50IHdpbGwgY29udGludWUgdG8gcmVuZGVyIHRoZVxuICogc3VwcGxpZWQgYHZhbHVlYCBwcm9wIGluc3RlYWQgb2YgdGhlIGV4cGVjdGVkIHJlc3VsdCBvZiBhbnkgdXNlciBhY3Rpb25zLlxuICovXG5jbGFzcyBTd2l0Y2ggZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8UHJvcHM+IHtcbiAgX25hdGl2ZVN3aXRjaFJlZjogP1JlYWN0LkVsZW1lbnRSZWY8XG4gICAgdHlwZW9mIFN3aXRjaE5hdGl2ZUNvbXBvbmVudCB8IHR5cGVvZiBBbmRyb2lkU3dpdGNoTmF0aXZlQ29tcG9uZW50LFxuICA+O1xuXG4gIHJlbmRlcigpOiBSZWFjdC5Ob2RlIHtcbiAgICBjb25zdCB7XG4gICAgICBkaXNhYmxlZCxcbiAgICAgIGlvc19iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIG9uVmFsdWVDaGFuZ2UsXG4gICAgICBzdHlsZSxcbiAgICAgIHRodW1iQ29sb3IsXG4gICAgICB0cmFja0NvbG9yLFxuICAgICAgdmFsdWUsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gU3VwcG9ydCBkZXByZWNhdGVkIGNvbG9yIHByb3BzLlxuICAgIGxldCBfdGh1bWJDb2xvciA9IHRodW1iQ29sb3I7XG4gICAgbGV0IF90cmFja0NvbG9yRm9yRmFsc2UgPSB0cmFja0NvbG9yPy5mYWxzZTtcbiAgICBsZXQgX3RyYWNrQ29sb3JGb3JUcnVlID0gdHJhY2tDb2xvcj8udHJ1ZTtcblxuICAgIC8vIFRPRE86IFJlbW92ZSBzdXBwb3J0IGZvciB0aGVzZSBwcm9wcyBhZnRlciBhIGNvdXBsZSByZWxlYXNlcy5cbiAgICBjb25zdCB7dGh1bWJUaW50Q29sb3IsIHRpbnRDb2xvciwgb25UaW50Q29sb3J9ID0gKHByb3BzOiAkRmxvd0ZpeE1lKTtcbiAgICBpZiAodGh1bWJUaW50Q29sb3IgIT0gbnVsbCkge1xuICAgICAgX3RodW1iQ29sb3IgPSB0aHVtYlRpbnRDb2xvcjtcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnU3dpdGNoOiBgdGh1bWJUaW50Q29sb3JgIGlzIGRlcHJlY2F0ZWQsIHVzZSBgdGh1bWJDb2xvcmAgaW5zdGVhZC4nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGludENvbG9yICE9IG51bGwpIHtcbiAgICAgIF90cmFja0NvbG9yRm9yRmFsc2UgPSB0aW50Q29sb3I7XG4gICAgICBpZiAoX19ERVZfXykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1N3aXRjaDogYHRpbnRDb2xvcmAgaXMgZGVwcmVjYXRlZCwgdXNlIGB0cmFja0NvbG9yYCBpbnN0ZWFkLicsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvblRpbnRDb2xvciAhPSBudWxsKSB7XG4gICAgICBfdHJhY2tDb2xvckZvclRydWUgPSBvblRpbnRDb2xvcjtcbiAgICAgIGlmIChfX0RFVl9fKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnU3dpdGNoOiBgb25UaW50Q29sb3JgIGlzIGRlcHJlY2F0ZWQsIHVzZSBgdHJhY2tDb2xvcmAgaW5zdGVhZC4nLFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChQbGF0Zm9ybS5PUyA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgICBjb25zdCBwbGF0Zm9ybVByb3BzID0ge1xuICAgICAgICBlbmFibGVkOiBkaXNhYmxlZCAhPT0gdHJ1ZSxcbiAgICAgICAgb246IHZhbHVlID09PSB0cnVlLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgdGh1bWJUaW50Q29sb3I6IF90aHVtYkNvbG9yLFxuICAgICAgICB0cmFja0NvbG9yRm9yRmFsc2U6IF90cmFja0NvbG9yRm9yRmFsc2UsXG4gICAgICAgIHRyYWNrQ29sb3JGb3JUcnVlOiBfdHJhY2tDb2xvckZvclRydWUsXG4gICAgICAgIHRyYWNrVGludENvbG9yOlxuICAgICAgICAgIHZhbHVlID09PSB0cnVlID8gX3RyYWNrQ29sb3JGb3JUcnVlIDogX3RyYWNrQ29sb3JGb3JGYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxBbmRyb2lkU3dpdGNoTmF0aXZlQ29tcG9uZW50XG4gICAgICAgICAgey4uLnByb3BzfVxuICAgICAgICAgIHsuLi5wbGF0Zm9ybVByb3BzfVxuICAgICAgICAgIGFjY2Vzc2liaWxpdHlSb2xlPXtwcm9wcy5hY2Nlc3NpYmlsaXR5Um9sZSA/PyAnYnV0dG9uJ31cbiAgICAgICAgICBvbkNoYW5nZT17dGhpcy5faGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIG9uUmVzcG9uZGVyVGVybWluYXRpb25SZXF1ZXN0PXtyZXR1cm5zRmFsc2V9XG4gICAgICAgICAgb25TdGFydFNob3VsZFNldFJlc3BvbmRlcj17cmV0dXJuc1RydWV9XG4gICAgICAgICAgcmVmPXt0aGlzLl9oYW5kbGVTd2l0Y2hOYXRpdmVDb21wb25lbnRSZWZ9XG4gICAgICAgIC8+XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYXRmb3JtUHJvcHMgPSB7XG4gICAgICBkaXNhYmxlZCxcbiAgICAgIG9uVGludENvbG9yOiBfdHJhY2tDb2xvckZvclRydWUsXG4gICAgICBzdHlsZTogU3R5bGVTaGVldC5jb21wb3NlKFxuICAgICAgICB7aGVpZ2h0OiAzMSwgd2lkdGg6IDUxfSxcbiAgICAgICAgU3R5bGVTaGVldC5jb21wb3NlKFxuICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgIGlvc19iYWNrZ3JvdW5kQ29sb3IgPT0gbnVsbFxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGlvc19iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAxNixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgKSxcbiAgICAgICksXG4gICAgICB0aHVtYlRpbnRDb2xvcjogX3RodW1iQ29sb3IsXG4gICAgICB0aW50Q29sb3I6IF90cmFja0NvbG9yRm9yRmFsc2UsXG4gICAgICB2YWx1ZTogdmFsdWUgPT09IHRydWUsXG4gICAgfTtcblxuICAgIHJldHVybiAoXG4gICAgICA8U3dpdGNoTmF0aXZlQ29tcG9uZW50XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgey4uLnBsYXRmb3JtUHJvcHN9XG4gICAgICAgIGFjY2Vzc2liaWxpdHlSb2xlPXtwcm9wcy5hY2Nlc3NpYmlsaXR5Um9sZSA/PyAnYnV0dG9uJ31cbiAgICAgICAgb25DaGFuZ2U9e3RoaXMuX2hhbmRsZUNoYW5nZX1cbiAgICAgICAgb25SZXNwb25kZXJUZXJtaW5hdGlvblJlcXVlc3Q9e3JldHVybnNGYWxzZX1cbiAgICAgICAgb25TdGFydFNob3VsZFNldFJlc3BvbmRlcj17cmV0dXJuc1RydWV9XG4gICAgICAgIHJlZj17dGhpcy5faGFuZGxlU3dpdGNoTmF0aXZlQ29tcG9uZW50UmVmfVxuICAgICAgLz5cbiAgICApO1xuICB9XG5cbiAgX2hhbmRsZUNoYW5nZSA9IChldmVudDogU3dpdGNoQ2hhbmdlRXZlbnQpID0+IHtcbiAgICBpZiAodGhpcy5fbmF0aXZlU3dpdGNoUmVmID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGb3JjZSB2YWx1ZSBvZiBuYXRpdmUgc3dpdGNoIGluIG9yZGVyIHRvIGNvbnRyb2wgaXQuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnByb3BzLnZhbHVlID09PSB0cnVlO1xuICAgIGlmIChQbGF0Zm9ybS5PUyA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgICB0aGlzLl9uYXRpdmVTd2l0Y2hSZWYuc2V0TmF0aXZlUHJvcHMoe29uOiB2YWx1ZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9uYXRpdmVTd2l0Y2hSZWYuc2V0TmF0aXZlUHJvcHMoe3ZhbHVlfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2UgIT0gbnVsbCkge1xuICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucHJvcHMub25WYWx1ZUNoYW5nZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnByb3BzLm9uVmFsdWVDaGFuZ2UoZXZlbnQubmF0aXZlRXZlbnQudmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBfaGFuZGxlU3dpdGNoTmF0aXZlQ29tcG9uZW50UmVmID0gKFxuICAgIHJlZjogP1JlYWN0LkVsZW1lbnRSZWY8XG4gICAgICB0eXBlb2YgU3dpdGNoTmF0aXZlQ29tcG9uZW50IHwgdHlwZW9mIEFuZHJvaWRTd2l0Y2hOYXRpdmVDb21wb25lbnQsXG4gICAgPixcbiAgKSA9PiB7XG4gICAgdGhpcy5fbmF0aXZlU3dpdGNoUmVmID0gcmVmO1xuICB9O1xufVxuXG5jb25zdCByZXR1cm5zRmFsc2UgPSAoKSA9PiBmYWxzZTtcbmNvbnN0IHJldHVybnNUcnVlID0gKCkgPT4gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBTd2l0Y2g7XG4iXX0=